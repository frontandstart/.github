.container
  %h2.text-center üê≥ Ruby on Rails development using Docker
  %p.text-center
    %s Shut up
    and just show me the code
    = icon_svg "github", add_class: 'github-icon'
    = link_to "github.com/frontandstart/initapp-rails", "https://github.com/frontandstart/initapp-rails", target: "_blank"

  %p.text-center
    Article will be helpfull if you just beginning with Docker or may be help to improve your setup. 

  %h3 How we handle setup of Ruby or any other language project before?
  %ol
    %li Install tons of version managers like rbenv, rvm, nvm, pyenv, asdf etc.
    %li Using that version manager install required for a project language version
    %li Install system dependecies like libyaml, gcc, make, etc using system package manager like apt, yum, brew etc.
    %li Try to run application meet yet another missing dependency like database library and goes back to step 3 again and again
    %li Spend hours to fix all the issues and finally run the application

  %h3 How we handle it now?
  %ol
    %li Install Docker
    %li Build the image
    %li Run the application

  %h3 Is it that simple?
  %p 
    Yes, it is and of course it add layer of complexity but once you learn it or did it for your project - probablby you will never go back to the old way of handling project setup.
    Lets detailed overview how it works. You may need to know some basic concepts that Docker uses like image, container, volume.
    %br
  
  .d-flex
    %div
      %b Image
      %blockquote
        %p A container image is a standardized package that includes all of the files, binaries, libraries, and configurations to run a container.
        %cite
          = link_to "Docker docs", "https://docs.docker.com/guides/docker-concepts/the-basics/what-is-an-image/", target: "_blank"
    %div
      %b Container
      %blockquote
        %p Simply put, containers are isolated processes for each of your app's components. Each component - the frontend React app, the Python API engine, and the database - runs in its own isolated environment, completely isolated from everything else on your machine.
        %cite
          = link_to "Docker docs", "https://docs.docker.com/guides/docker-concepts/the-basics/what-is-a-container/", target: "_blank"
    %div
      %b Volume
      %blockquote
        %p Basically volume is named folder at you host machine that is can be mounted to the container file system. It is used to persist data generated by and used by Docker containers.
        %cite
          = link_to "Docker docs", "https://docs.docker.com/storage/volumes/", target: "_blank"
  %h5.text-center
    Docker development enviroment will be need
    %i Dockerfile
    and
    %i compose.yaml
    files
  %h3.text-center
    Lets go through 
    %i Dockerfile
  %p<
    Dockerfile is a list of instructions for docker to build an image.
    Our Dockerfile maden from own exprience and partly inspired by:
    %ul
      %li
        = link_to "Evilmatians article", "https://evilmartians.com/chronicles/ruby-on-whales-docker-for-ruby-rails-development", target: "_blank"
      %li
        = link_to "github.com/rails/docked", "https://github.com/rails/docked", target: "_blank"
    
  %ul
    %li
      %p
        We try making it simple as it possible, lets take a look.     
        As you can see our Dockerfile splitted into two stages:
        %ul
          %li
            %b Development
            for locally run application and tests:
            %i line 1 to 34 
          %li
            %b Production
            for builiding production image at CI and deploying:
            %i line 34 to 42
  .d-flex
    .dockerfile-description
      %ul
        %h5 Development stage
        %li
          At first line we pick our
          = link_to "ruby version, distributive", "https://hub.docker.com/_/ruby/tags", target: "_blank"
          and use it as base image for example:
          %code FROM ruby:3.2.5-slim-bullseye AS development
        %li 
          Ruby on Rails is dependend from nodejs and yarn or npm for assets compilation.
          %br
          Instead of installing them from system package manager we use already compiled from corresponding distributive docker image.
          %pre
            :plain
              COPY --from=node:20.16.0-bullseye-slim /usr/local/bin/node /usr/local/bin/
              COPY --from=node:20.16.0-bullseye-slim /usr/local/lib/node_modules /usr/local/lib/node_modules
              COPY --from=node:20.16.0-bullseye-slim /opt/yarn-v1.22.22 /opt/yarn-v1.22.22

              RUN ln -s /usr/local/bin/node /usr/local/bin/nodejs && \
                  ln -s /usr/local/lib/node_modules/npm/bin/npm-cli.js /usr/local/bin/npm && \
                  ln -s /usr/local/lib/node_modules/npm/bin/npx-cli.js /usr/local/bin/npx && \
                  ln -s /usr/local/lib/node_modules/corepack/dist/corepack.js /usr/local/bin/corepack && \
                  ln -s /opt/yarn-v1.22.22/bin/yarn /usr/local/bin/yarn && \
                  ln -s /opt/yarn-v1.22.22/bin/yarnpkg /usr/local/bin/yarnpkg
        %li
          %code.inline RUN apt-get update -y && apt-get install...
          at
          %i line 14
          we install ruby and project system dependencies like libyaml, gcc, make, etc using system package manager
        %li
          %code.inline WORKDIR /app
          Set working folder where we will store our project files
        %li
          %code.inline RUN gem install bundler foreman
          install bundler gem for managing ruby dependencies and foreman for starting multiple development application processes.
        %li
          %code.inline ENV BUNDLE_JOBS=$(nproc)
          this enviroment varible using by bundler for parallels gems install. We set same amount of cores that you has.
          In docker desktop settings you can manage how many cores you want to provide.   
        %br
        %p
          We rebuild development image only in case of changing ruby version, distributive or added new system dependency.
          Didn't save source code and not installing gems, nodejs modules becouse we install them in mounted volumes to share them beetween runs.
          See detailed explanation below at
          %i compose.yaml
          file part.
      %ul
        %h5 Production stage
        %li
          %code.inline ENV BUNDLE_JOBS=$(nproc)
          Re-define bundler paralles workers becouse usually we build production stage only into CI machine that has different from development amount of cores  
        %li
          %code.inline COPY . .
          Copy source code from host current folder (first dot) to the current working directory at docker image (second dot) whitch is setted at development stage as
          %i /app
        %li
          %code.inline RUN bundle config set production true
          This bundler settings will change way how the bundler install gems by skipping system files, tests, .git directory to reduce production image size
        %li
          %code.inline RUN bundle install
          Install ruby gems into production docker image
        %li
          %code.inline RUN bundle exec rails assets:precompile
          Compile assets ino public folder
    .dockerfile-content
      %script{src: "https://gist.github.com/r3cha/994e108d0b52935797b5132ca452cb5f.js"}

  %h3.text-center
    Let's explore
    %i compose.yaml
    file
  %p
    File may contains six main top-level keys.
    We will focus only on
    %b services
    and
    %b volumes
    %ul
      %li
        %b name
        \- name of the application
      %li |
        %b services
        \- list of services (containers) that will be run
      %li
        %b volumes
        \- list of volumes that will be used by services
      %li
        %b networks
        \- list of networks that will be used by services
      %li
        %b secrets
        \- list of secrets that will be used by services
      %li
        %b configs
        \- list of configs that will be used by services
  %p
    Read more detailed at official docker compose file
    = link_to "specification", "https://docs.docker.com/compose/compose-file/", target: "_blank"

  .d-flex
    .docker-compose-desc
      %ul
        %h4 Services
        %li
          %h5 App
          %p service is our Rails application container and most important part. We will overview all nested keys:
          %ul
            %li
              %p
                %strong build:
                %br
                Section used by 
                %code.inline
                  docker compose build app
                command to build our image and tag is by name that read from
                %b image
                key
                %i initapp-rails
                in out case. Last
                %b app
                is argument witch is name of our service.
                So it will same as command:
                %code 
                  docker build -t initapp-rails --target development .
                Where
                %code.inline
                  \.
                is context (current directory), target is development stage at Dockerfile and initapp-rails is name of our generated image.
                %br
                Docker commannd use
                %i Dockerfile
                from working directory by default. Specify another file by simply adding
                %b dockerfile
                to 
                %b build
                section
                %code
                  :plain
                    services: 
                      app:
                        build:
                          dockerfile: Dockerfile.other
                %br
                And now
                %code.inline
                  docker compose build app
                will be equal to the:      
                %code
                  docker build -t initapp-rails --target development -f Dockerfile.other .           
            %li
              %p
                %strong env_file:
                %br
                List of file with environment varibles that will be passed to the container at runtime.
                %br
                %i .docker.env
                contains list of basic environments that we need to run development application
                %br
                %i .env
                is gitignored file where your can store own secrets required for development or debugging third-party integrations.
                We ensure th  at exists before application starts by
                %code.inline
                  touch .env
            
            %li
              %p
                %strong stdin_open: true
                %br
                For debugging application usign debugger gem, read how at  
                = link_to "readme", "https://github.com/frontandstart/initapp-rails?tab=readme-ov-file#debugging-inside-docker-container", target: "_blank"
                section.
            
            %li
              %p
                %strong ports:
                %br
                Here is a list of ports that will be exposed from container to your host machine in format:
                %code.inline<>
                  \- host_port:container_port
                \.
                We use
                %code.inline
                  ${PORT:-3000}
                for host and container - read it as
                %i using PORT environment varible if it is set or 3000 by default.
                %br
                We solve two things with this code:
                %br
                You able to run few projects at the same time by setting own 
                %code.inline
                  PORT=4000
                environment varible at 
                %i .env
                file.
                %br
                Also 
                %code.inline
                  PORT
                is used by default by puma or foreman as a port where application running
                and you will see nice output with a container port at console that will match with host.
                %code
                  :plain
                    app-1  | Puma starting in single mode...
                    app-1  | * Puma version: 6.4.2 (ruby 3.2.5-p208) ("The Eagle of Durango")
                    app-1  | *  Min threads: 5
                    app-1  | *  Max threads: 5
                    app-1  | *  Environment: development
                    app-1  | *          PID: 1
                    app-1  | * Listening on http://0.0.0.0:4000
                    app-1  | Use Ctrl-C to stop
                No need to remember or open 
                %i
                  docker-compse.yml
                file to refresh on which port application is running.
            %li
              %p
                %strong tmpfs
                %br
                This list of folders will be mounted as temporary volume. It is used to store temporary files that are not persisted between container restarts.
                Every restart of puma there will be generated new pidfile.
            %li
              %p
                %strong depends_on
                %br
                Here we define that our app container depends on postgres and redis container. It means that app container will be started after postgres and redis containers.
                %code
                  condition: service_healthy
                Ensure that postgres and redis containers are healthy before starting app container. You can define how to check that container is healthy by configuring
                %code.inline
                  healthcheck:
                section.
            %li
              %p
                %strong healthcheck
                %br
                Here we define how docker will ensure that containers are healthy.
                Healthy mean that command at 
                %code
                  :plain
                    healthcheck:
                      test: ["CMD", "redis-cli", "ping"]
                block will exited and exited with 0 (success) status code. And self-explaningable fields to set healtcheck interval, timeout and retries.
            %li
              %p
                %strong volumes
                %br
                Here we define list of volumes that will be mounted to the container.
                It can be some relative path from you project root directory like:
                %br
                %code.inline
                  \- ./:/app
                mount our project root directory to the container at /app folder whitch is default WORKDIR at
                %i Gemfile
                \.
                %br
                Or named volumes for sharing data between container run like:
                %br
                %code.inline
                  \- cache:/app/tmp/cache:d
                rails cache files.
                %br
                %code.inline
                  \- bundle:/usr/local/bundle:d
                storing ruby gems.
                %br
                %code.inline
                  \- data:/data:d
                general data like history files bet, see
                HISTFILE, PSQL_HISTORY, PRY_HISTORY enviroments at 
                %i .docker.env
                file.

              %p.note
                You must define named volume at 
                %code.inline
                  volumes:
                section. 
            %li
              %p
                %strong command
                %br
                Shell script
                %code.inline
                  bin/dev-start.sh
                containing:
                %code
                  bundle check || bundle install
                  yarn install
                  bundle exec rails db:create db:migrate
                  foreman start -f Procfile.dev
                that running inside app container when docker compose start.
                It ensure that ruby gems and node_modules installed, create database at first run and apply rails migrations,
                run processes listed at
                %i Procfile.dev
                like: puma, css and js compilation.


        %li
          %h5 Redis
          %p
            The 
            %b redis
            Run Redis database container. That we use for sidekiq jobs processing.

        %li
          %h5 Postgres
          %p
            Run a PostgreSQL database container. It uses a specific image version 
            and maintains persistent data through a
            %b postgres
            named volume.

      %h4 Volumes
      %p
        Volumes are used to persist data between containers restarts.
        Once you define it docker will create it following 
        %code.inline
          ${name_section_or_root_folder_name}_${volume_name}
        convention. For example in our project for
        %i data
        volume complete name will be
        \ 
        %i<>
          initapp-rails_data
        \. Run
        %code.inline
          docker volume inspect initapp-rails_data
        to see volume details and exact location at your machine.

    .docker-compose-content
      %script{src: "https://gist.github.com/r3cha/6c4e8c999b65833820bb5b69b1f763e2.js"}

  %h3.text-center
    How to up everuthing?
  %p.text-center
    Build development image:
    %code.inline
      docker compose build app
    %br
    Run application:
    %code.inline
      docker compose up
    
  %p
    Here is what happening:
    %ul
      %li
        %code
          docker compose build app
        Docker compose will parse
        %b build
        secton of
        %b app
        service and generating command like this: 
        %code.inline
          docker build --tag initapp-rails --target development .
        where 
        %b development
        is target,
        %b dot
        is stage and 
        %b initapp-rails
        is value of
        %b name
        key.

      %li
        %p
          %code
            docker compose up
          Docker compose looking locally for images tagged same as 
          %b image:
          section of compose file. Once failed it will try pull it from 
          = link_to "docker hub", "https://hub.docker.com"
          container registry. For our case it will pull
          = link_to "https://hub.docker.com/_/postgres/tags?page=&page_size=&ordering=&name=16.4-bullseye" do
            %b postgres:16.4-bullseye
          and
          = link_to "https://hub.docker.com/_/redis/tags?page=&page_size=&ordering=&name=7.4.0" do     
            %b redis:7.4.0
          images and use already builded 
          %b initapp-rails
          image run all containers for all services, mounting volumes, expose ports from containers into you computer.

  %p.note
    Older version of docker came with 
    %b docker-compose
    utility written on python that nowdays rewrited on golang and moved to
    %b docker compose
    subcommand of 
    %b docker
    cli. 
    %b Docker compose
    read configuration from
    %i compose.yaml
    file and run all containers described at
    %b services
    section. You may use another file by passing
    %code.inline
      \-f
    option to
    %b docker compose
    command like: 
    %code.inline
      docker compose -f docker-compose.prod.yml up

  %p.warn
    Basically you can pull and build images using just 
    %code.inline docker compose up

    but we recomed build yoor local images first then up, becouse someone may occupy docker hub username 
    like
    %b initapp-rails:latest
    
    or whatever you will be using locally and upload own image, that you will pull and run using just
    %code.inline docker compose up
    command initially.

  %p.note
    Our
    %b services
    section contains four nested keys 
    :plain
      <b>app</b>, <b>sidekiq</b>, <b>redis</b> and <b>postgres</b>
    that turn into containers when we run
    %code.inline
      docker compose up
  %p
    With this command you run your containers and terminal will be attached to the containers STDOUT and logs will be printed,
    by clicking CTRL+C command you will stop containers.
    %br
    You can run
    %code.inline docker compose up -d
    in deattached (background) mode, then you will be able to see logs of all services with
    %code.inline docker compose logs
    or passing service name to stream logs for specific container
    %code.inline docker compose logs app

  %p
    Whatever you have running container or not you able to 
    %b run
    specific container and command like:
    %code.inline docker compose run app bash
    this will run app container with bash session in it.
    %br
    Or you may run specific rails command and exit: 
    %code.inline docker compose run app rails routes

  %p
    Once you up containers from another terminal window you able to 
    %b exec
    (enter) into any container with
    %code.inline docker compose exec app
    replace 
    %b app
    wih
    :plain
      <b>sidekiq</b>, <b>redis</b> or <b>postgres</b>
    to choise container that you want to enter.
  %p.note
    We use  
    = link_to "foreman", "https://github.com/ddollar/foreman", target: "_blank"
    gem inside app container for running rails application, js, css compilation processes.
    Alternatively you may remove foreman and use separate containers for css and js.
    Checkout this short article
    = link_to "foreman or containers", page_path(path: "separate-containers-vs-foreman-for-compiling-assets-into-development"), target: "_blank"
    if you want to use another approach.

  %p
    Read more at docker compose cli
    = link_to "docs", "https://docs.docker.com/compose/compose-application-model/", target: "_blank"

  %h3 
